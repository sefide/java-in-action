## 스트림 

데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소 

<br>

#### 정의

- **연속된 요소** : 컬렉션과 같이 연속된 값 집합의 인터페이스를 제공하지만, 컬렉션은 **데이터**의 시/공간 복잡성 및 저장에 대해 집중하지만 데이터고 스트림은 **연산/계산**에 집중
- **소스** : 컬렉션, 배열, I/O 자원 등으로 제공받은 소스를 소비하는데, 컬렉션의 경우 요소 순서를 유지
- **데이터 처리 연산** : 데이터베이스와 비슷한 연산을 제공

#### 특징

- **파이프라이닝** : 스트림 연산끼리 연결해서 커다란 파이프라인을 구성할 수 있도록 스트림 자신을 반환하는 연산이 대부분 => 레이지, 쇼트서킷
- **내부 반복**

#### 장점 

- **선언형** : if문이나 반복문 등의 제어 블록(임시 구현 코드)을 사용할 필요없이, 선언형으로 코드를 간결하게 구현하여 가독성을 높인다. 
- **유연성** : filter, map, sorted, collect와 같은 연산(고수준 빌딩 블록)을 이용해 복잡한 데이터 처리 파이프라인을 만들 수 있다. 
- **병렬성** : 스레드와 락 걱정없이 꽤 투명하게 멀티 코어 아키텍처에서 활용할 수 있다. 



**스트림의 인터페이스 정의** : java.util.stream.Stream

자바8 컬렉션에 추가된 stream 메서드


<br>

---

### 컬렉션과의 차이 

#### 데이터를 언제 계산하느냐

**컬렉션**

=> 모든 요소는 컬렉션에 추가하기 전에 계산되어야 함. (자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조)

=> 요소 추가/제거 가능

**스트림**

=> 사용자가 데이터를 요청할 떄만 요소를 계산. (게으르게 만들어지는 컬렉션)

=> 요소 추가/제거 불가능


#### 딱 한번만 탐색

스트림은 딱 한번만 탐색할 수 있다. (forEach) 이후에는 스트림이 소비 완료/닫힘

#### 외부 반복, 내부 반복

**컬렉션**

=> 외부 반복 (for-each, Iterator을 사용한 반복)

**스트림**

=> 내부 반복 (반복을 알아서 처리하고 결과 값을 어딘가에 저장해줌) <br>
=> 반복 관리를 따로 하지 않아도 된다. 병렬성 구현 자동 선택

<br>

---

#### 스트림 연산

**중간 연산** 

=> 연결할 수 있는 스트림 연산 (filter, map, limit..)

=> 종단 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다. (lazy)



**최종 연산**

=> 스트림을 닫는 연산 (collect, forEach.. )

=> 스트림 파이프라인에서 결과를 도출한다.

<br>

[^쇼트서킷]: 여러 개의 조건을 중첩할 때, (or 연산 시) 참 / (and 연산 시)거짓이 우선 확정되면 뒤의 조건은 검사하지 않는다.

[^루프 퓨전]: 

